var eventDuration = require("../utils/eventDuration");

module.exports = AudioBufferRecorder;

function AudioBufferRecorder(trackModel){
    this.track = null; // current track
    this.playData = null; // playing data for current track
    this.duration = 0; // duration for current track
    this.trackModel = trackModel;
    this.filterObjects = {};
    this.setModel(trackModel);
}

AudioBufferRecorder.prototype.setModel = function(trackModel){
    if(trackModel){
        this.trackModel = trackModel;
        this.createTrack();
    }
};

/**
 * Again create track and filters for record them to Offline
 */
AudioBufferRecorder.prototype.createTrack = function(){
    this.filterObjects.length = 0;
    switch(this.trackModel.instrument){
        case "synth":
            this.track = new Tone.Synth(this.trackModel.setting).toMaster();
            this.playData = createSynthPlayData(this.trackModel.playObjects);
            this.duration = eventDuration.keyDuration(this.playData);
            break;
        case "drum":
            this.track = null;
            break;
        case "oscillator":
            this.track = new Tone.Oscillator(this.trackModel.setting).toMaster();
            this.playData = createOscillatorPlayData(this.trackModel.playObjects);
            this.duration = eventDuration.durationByTime(this.playData);
            break;
        case "noise":
            this.track = new Tone.NoiseSynth();
            break;
    }
    this.createFilters();
};

AudioBufferRecorder.prototype.createFilter = function(filterName, filterSetting){
    switch(filterName){
        case "tremolo":
            this.filterObjects[filterName] = new Tone.Tremolo(filterSetting);
            break;
        case "vibrato":
            this.filterObjects[filterName] = new Tone.Vibrato(filterSetting);
            break;
        case "crusher":
            this.filterObjects[filterName] = new Tone.BitCrusher(filterSetting);
            break;
        case "phaser":
            this.filterObjects[filterName] = new Tone.Phaser(filterSetting);
            break;
        case "freeverb":
            this.filterObjects[filterName] = new Tone.Freeverb(filterSetting);
            break;
    }
};

AudioBufferRecorder.prototype.createFilters = function(){
    var name;
    if(Object.keys(this.trackModel.postSettings.filterObjects).length !== 0){
        this.track.disconnect(Tone.Master); // disconnect track from Master only if it has applying to filter/s
    }
    for(name in this.trackModel.postSettings.filterObjects){
        this.createFilter(name, this.trackModel.postSettings.filterObjects[name].getOptions());
        this.applyFilterToTrack(this.filterObjects[name]);
    }
};

/**
 * Apply all filters from filterObjects to one track
 */
AudioBufferRecorder.prototype.applyFilterToTrack = function(filter){
    filter.toMaster();
    this.track.connect(filter);
};

/**
 * Play events for track
 * @param instrument - String - instrument name
 * @param value - Object - object with play values
 */
AudioBufferRecorder.prototype.play = function(instrument, value){
    var self = this;
    switch(instrument){
        case "synth":
            this.track.triggerAttackRelease(value.note, value.duration, value.time);
            break;
        case "drum":
            break;
        case "oscillator":
            setTimeout(function(){
                self.track.frequency.value = value.frequency;
                self.track.volume.value = value.volume;
            }, value.time*1000);
            this.track.start(value.time);
            //this.track.stop();
            break;
        case "noise":
            break;
    }
};

AudioBufferRecorder.prototype.record = function(callback){
    var self = this;
    Tone.Offline(function(){
        self.createTrack(self.trackModel.instrument);
        var part = new Tone.Part(function(time, value){
            // record all play values
            self.play(self.trackModel.instrument, value);
            console.log(time, self.duration, value);
        }, self.playData);
        part.start(0);
        Tone.Transport.start();
    }, this.duration).then(function(buffer){
        console.log("result");
        console.log(buffer._buffer);
        callback(buffer._buffer);
    });
};

function createSynthPlayData(trackPlayData){
    var events = [];
    var tmp, i;
    for(i = 0; i < trackPlayData.length; ++i){
        tmp = {};
        tmp.time = trackPlayData[i].triggerAttackTime / 1000;
        tmp.duration = trackPlayData[i].triggerReleaseTime / 1000;
        tmp.note = trackPlayData[i].note;
        events.push(tmp);
    }
    return events;
}

function createOscillatorPlayData(trackPlayData){
    var events = [];
    var tmp, i;
    for(i = 0; i < trackPlayData.length; ++i){
        tmp = {};
        tmp.time = trackPlayData[i].startTime / 1000;
        tmp.frequency = trackPlayData[i].frequency;
        tmp.volume = trackPlayData[i].volume;
        events.push(tmp);
    }
    return events;
}
