var inherit = require("../utils/inherit");
var TrackManager = require("../utils/TrackManager");
var AudioBufferRecorder = require("./AudioBufferRecorder");
var eventDuration = require("../utils/eventDuration");

module.exports = DrumAudioBufferRecorder;

function DrumAudioBufferRecorder(drumModel){
    AudioBufferRecorder.call(this, drumModel);
    this.drumCount = 0;
    this.drumAudioBuffers = [];
    this.durationList = {};
    this.playDataList = {};
}

inherit(DrumAudioBufferRecorder, AudioBufferRecorder);

DrumAudioBufferRecorder.prototype.setModel = function(drumModel){
    if(drumModel){
        this.trackModel = drumModel;
        this.drumCount = drumModel.drums.length;
        this.createTracks();
    }
};

DrumAudioBufferRecorder.prototype.createTrack = function(drumTrack){
    this.filterObjects.length = 0;  // empty previous track filters
    if(drumTrack instanceof AudioBuffer){
        // create sound from buffer
        this.track = new Tone.Player(drumTrack).toMaster();
    } else{
        // create sound from drum model
        if(drumTrack.trackObject instanceof Tone.MembraneSynth){
            this.track = new Tone.MembraneSynth(drumTrack.setting).toMaster();
        } else if(drumTrack.trackObject instanceof Tone.MetalSynth){
            this.track = new Tone.MetalSynth(drumTrack.setting).toMaster();
        } else if(drumTrack.trackObject instanceof Tone.Player){
            this.track = new Tone.Player(drumTrack.url).toMaster();
        }
    }
    if(this.track){
        this.createFilters();
        //this.playData = createDrumPlayData(this.trackModel.playObjects, drumTrack.instrument);
        //this.duration = eventDuration.durationByTime(this.playData);
    }
    console.log("track");
    console.log(this.track);
};

DrumAudioBufferRecorder.prototype.createTracks = function(){
    var drum, name;
    for(name in this.trackModel.drumObjects){
        drum = this.trackModel.drumObjects[name];
        this.createTrack(drum);
        // save play data and duration at once
        // save play data of each track in object: key - instrument name, value - array of objects with playing data
        this.playDataList[drum.instrument] = createDrumPlayData(this.trackModel.playObjects, drum.instrument);
        // save duration of each track in object: key - instrument name, value - duration
        this.durationList[drum.instrument] = eventDuration.durationByTime(this.playDataList[drum.instrument]);
    }
};

DrumAudioBufferRecorder.prototype.play = function(drumTrack, value){
    if(drumTrack.trackObject instanceof Tone.MembraneSynth){
        this.track.triggerAttack(value.playValue, value.time);
    } else if(drumTrack.trackObject instanceof Tone.Player){
        this.track.start(value.time);
    } else if(drumTrack.trackObject instanceof Tone.MetalSynth){
        this.track.triggerAttackRelease(value.playValue, value.time);
    }
};

DrumAudioBufferRecorder.prototype.recordAudioFile = function(drumTrack, callback){
    var buffer, bufferObject;
    var self = this;
    if(drumTrack.trackObject instanceof Tone.Player){
        bufferObject = new Tone.Buffer(drumTrack.url);
        Tone.Buffer.on("load", function(){
            buffer = bufferObject.get();
            // record buffer only when it completely loaded
            self._record(drumTrack, callback, buffer);
        });
    } else{
        this._record(drumTrack, callback);
    }
};

DrumAudioBufferRecorder.prototype.record = function(callback){
    var i, drumTrack;
    this.drumAudioBuffers.length = 0;
    for(i = 0; i < this.drumCount; ++i){
        // this.trackModel.drums[i] - drum instrument name
        drumTrack = this.trackModel.drumObjects[this.trackModel.drums[i]];
        // convert all drum objects to AudioBuffers
        this.recordAudioFile(drumTrack, callback);
    }
};

DrumAudioBufferRecorder.prototype._record = function(drumTrack, callback, buffer){
    var result; // result of merged AudioBuffer
    var self = this;
    // durationList[drumTrack.instrument] - duration of corresponded instrument
    var duration = this.durationList[drumTrack.instrument];
    // playDataList[drumTrack.instrument] - play data of corresponded instrument
    var playData = this.playDataList[drumTrack.instrument];
    console.log(drumTrack.instrument);
    console.log("duration");
    console.log(duration);
    Tone.Offline(function(){
        if(buffer){
            self.createTrack(buffer);
        } else{
            self.createTrack(drumTrack);
        }
        console.log("offline");
        console.log(playData);
        var part = new Tone.Part(function(time, value){
            // record all play values
            console.log("part");
            self.play(drumTrack, value);
        }, playData);
        part.start(0);
        Tone.Transport.start();
    }, duration).then(function(buffer){
        self.drumAudioBuffers.push(buffer._buffer); // save new audioBuffer in list
        console.log("then");
        console.log(buffer._buffer);
        console.log(self.drumAudioBuffers);
        if(self.drumAudioBuffers.length === self.drumCount){
            result = TrackManager.mergeTracks(self.drumAudioBuffers);
            console.log("result");
            console.log(result);
            callback(result);
        }
    });
};

function createDrumPlayData(trackPlayData, instrument){
    var events = [];
    var tmp, i, token;
    for(i = 0; i < trackPlayData.length; ++i){
        tmp = {};
        token = trackPlayData[i];
        if(token.instrument === instrument){
            tmp.time = token.startTime / 1000;
            if(token.playValue){
                tmp.playValue = token.playValue;
            }
            events.push(tmp);
        }
    }
    return events;
}
